"""
Interfejs u≈ºytkownika w terminalu
"""

import os
import time
from typing import List, Optional
from src.quiz_manager import QuizManager
from src.database import Database


class TerminalUI:
    """Interfejs u≈ºytkownika w terminalu"""
    
    def __init__(self, quiz_manager: QuizManager, database: Database):
        self.quiz_manager = quiz_manager
        self.db = database
        self.running = True
    
    def clear_screen(self):
        """Czy≈õci ekran terminala"""
        os.system('clear' if os.name == 'posix' else 'cls')
    
    def print_header(self, title: str):
        """Wy≈õwietla nag≈Ç√≥wek"""
        print(f"\n{'='*60}")
        print(f"üéì {title.center(54)} üéì")
        print(f"{'='*60}")
    
    def print_menu(self, options: List[str], title: str = "Menu"):
        """Wy≈õwietla menu z opcjami"""
        self.print_header(title)
        print()
        for i, option in enumerate(options, 1):
            print(f"  {i}. {option}")
        print(f"  0. Wyj≈õcie")
        print()
    
    def get_user_choice(self, max_option: int) -> int:
        """Pobiera wyb√≥r u≈ºytkownika"""
        while True:
            try:
                choice = input(f"Wybierz opcjƒô (0-{max_option}): ").strip()
                choice_int = int(choice)
                if 0 <= choice_int <= max_option:
                    return choice_int
                else:
                    print(f"‚ùå Proszƒô podaƒá liczbƒô od 0 do {max_option}")
            except ValueError:
                print("‚ùå Proszƒô podaƒá poprawnƒÖ liczbƒô")
            except KeyboardInterrupt:
                return 0
    
    def run(self):
        """G≈Ç√≥wna pƒôtla aplikacji"""
        while self.running:
            self.show_main_menu()
    
    def show_main_menu(self):
        """Wy≈õwietla g≈Ç√≥wne menu"""
        options = [
            "üìö Wybierz quiz",
            "üéØ Rozpocznij naukƒô (tryb powt√≥rek)",
            "üé≤ Tryb losowy",
            "üìä Wy≈õwietl statystyki",
            "üîç Problematyczne pytania",
            "‚öôÔ∏è  Ustawienia i narzƒôdzia"
        ]
        
        self.clear_screen()
        self.print_menu(options, "ZakuZaku - Menu G≈Ç√≥wne")
        
        # Wy≈õwietl informacje o aktualnym quizie
        current_quiz = self.quiz_manager.get_quiz_name()
        print(f"üìñ Aktualny quiz: {current_quiz}")
        
        if self.quiz_manager.current_quiz_file:
            stats = self.quiz_manager.get_quiz_statistics()
            print(f"üìà Pytania w bazie: {stats['total_questions']}")
            print(f"‚úÖ Dok≈Çadno≈õƒá: {stats['accuracy']:.1f}%")
        
        print()
        
        choice = self.get_user_choice(len(options))
        
        if choice == 0:
            self.running = False
        elif choice == 1:
            self.select_quiz()
        elif choice == 2:
            self.start_quiz("review")
        elif choice == 3:
            self.start_quiz("random")
        elif choice == 4:
            self.show_statistics()
        elif choice == 5:
            self.show_problem_questions()
        elif choice == 6:
            self.show_settings_menu()
    
    def select_quiz(self):
        """Menu wyboru quizu"""
        quizzes = self.quiz_manager.get_available_quizzes()
        
        if not quizzes:
            self.clear_screen()
            self.print_header("Brak quiz√≥w")
            print("\n‚ùå Nie znaleziono ≈ºadnych plik√≥w z quizami w katalogu 'quizy'")
            print("\nüí° Czy chcesz utworzyƒá przyk≈Çadowe quizy?")
            choice = input("Tak (t) / Nie (n): ").strip().lower()
            
            if choice in ['t', 'tak', 'y', 'yes']:
                self.quiz_manager.create_sample_quizzes()
                print("\n‚úÖ Utworzono przyk≈Çadowe quizy!")
                input("Naci≈õnij Enter, aby kontynuowaƒá...")
                return self.select_quiz()
            else:
                input("Naci≈õnij Enter, aby wr√≥ciƒá do menu...")
                return
        
        self.clear_screen()
        self.print_header("Wyb√≥r Quizu")
        
        print("\nDostƒôpne quizy:")
        for i, quiz_file in enumerate(quizzes, 1):
            quiz_name = os.path.basename(quiz_file).replace('.json', '').replace('.md', '').replace('_', ' ').title()
            print(f"  {i}. {quiz_name}")
            print(f"     üìÅ {quiz_file}")
        
        print(f"  0. Powr√≥t do menu g≈Ç√≥wnego")
        print()
        
        choice = self.get_user_choice(len(quizzes))
        
        if choice == 0:
            return
        
        selected_quiz = quizzes[choice - 1]
        print(f"\nüì• ≈Åadujƒô quiz: {selected_quiz}")
        
        if self.quiz_manager.load_quiz(selected_quiz):
            print("‚úÖ Quiz za≈Çadowany pomy≈õlnie!")
        else:
            print("‚ùå B≈ÇƒÖd podczas ≈Çadowania quizu!")
        
        input("Naci≈õnij Enter, aby kontynuowaƒá...")
    
    def start_quiz(self, mode: str):
        """Rozpoczyna quiz w wybranym trybie"""
        if not self.quiz_manager.current_quiz_file:
            self.clear_screen()
            print("‚ùå Najpierw wybierz quiz!")
            input("Naci≈õnij Enter, aby kontynuowaƒá...")
            return
        
        # Sprawd≈∫ czy sƒÖ pytania do zadania
        if mode == "review" and not self.quiz_manager.has_questions_for_review():
            self.clear_screen()
            print("üéâ Brawo! Wszystkie pytania zosta≈Çy opanowane!")
            print("üí° Spr√≥buj trybu losowego lub wr√≥ƒá p√≥≈∫niej dla powt√≥rek.")
            input("Naci≈õnij Enter, aby kontynuowaƒá...")
            return
        
        self.quiz_manager.reset_session_stats()
        mode_name = "Powt√≥rki (SRS)" if mode == "review" else "Tryb losowy"
        
        self.clear_screen()
        self.print_header(f"Quiz: {self.quiz_manager.get_quiz_name()} - {mode_name}")
        print("\nüéØ Rozpoczynamy quiz!")
        print("üí° Wskaz√≥wka: Wpisz 'quit' aby zako≈Ñczyƒá quiz")
        print("üí° Wskaz√≥wka: Wpisz 'skip' aby pominƒÖƒá pytanie")
        input("\nNaci≈õnij Enter, aby rozpoczƒÖƒá...")
        
        questions_count = 0
        max_questions = 20  # Limit pyta≈Ñ na sesjƒô
        
        while questions_count < max_questions:
            question_data = self.quiz_manager.get_next_question(mode)
            
            if not question_data:
                self.clear_screen()
                print("üéâ Excellent! Nie ma wiƒôcej pyta≈Ñ do zadania!")
                break
            
            # Wy≈õwietl pytanie
            self.clear_screen()
            self.print_header(f"Pytanie {questions_count + 1}/{max_questions}")
            
            print(f"\n‚ùì {question_data['question']}")
            
            # Wy≈õwietl opcje dla pyta≈Ñ wielokrotnego wyboru
            if question_data.get('options') and question_data.get('question_type') in ['single_choice', 'multiple_choice']:
                print("\nOpcje:")
                for i, option in enumerate(question_data['options']):
                    letter = chr(ord('A') + i)
                    print(f"  {letter}) {option}")
                
                if question_data.get('question_type') == 'multiple_choice':
                    print("\nüí° Wskaz√≥wka: Dla wielokrotnego wyboru podaj litery oddzielone przecinkami (np. A, C)")
                else:
                    print("\nüí° Wskaz√≥wka: Podaj literƒô (A, B, C, D) lub pe≈ÇnƒÖ odpowied≈∫")
            
            print()
            
            # Zmierz czas odpowiedzi
            start_time = time.time()
            user_answer = input("üí≠ Twoja odpowied≈∫: ").strip()
            response_time = time.time() - start_time
            
            # Sprawd≈∫ czy u≈ºytkownik chce zako≈Ñczyƒá
            if user_answer.lower() in ['quit', 'exit', 'koniec']:
                break
            
            # Sprawd≈∫ czy u≈ºytkownik chce pominƒÖƒá
            if user_answer.lower() in ['skip', 'pomi≈Ñ']:
                print("‚è≠Ô∏è  Pytanie pominiƒôte")
                time.sleep(1)
                continue
            
            # Sprawd≈∫ odpowied≈∫
            is_correct = self.quiz_manager.check_answer(
                question_data['db_id'],
                user_answer,
                question_data['correct_answer'],
                question_data.get('question_type', 'text'),
                question_data.get('options'),
                question_data.get('correct_answers'),
                response_time
            )
            
            # Wy≈õwietl wynik
            if is_correct:
                print("‚úÖ Poprawnie!")
            else:
                print(f"‚ùå B≈Çƒôdna odpowied≈∫!")
                print(f"üí° Poprawna odpowied≈∫: {question_data['correct_answer']}")
                
                # Dla pyta≈Ñ wielokrotnego wyboru poka≈º dodatkowe informacje
                if question_data.get('question_type') == 'multiple_choice' and question_data.get('correct_answers'):
                    print("üí° Poprawne opcje:")
                    options = question_data.get('options', [])
                    for answer in question_data['correct_answers']:
                        # Znajd≈∫ literƒô dla odpowiedzi
                        for i, option in enumerate(options):
                            if option.strip().lower() == answer.strip().lower():
                                letter = chr(ord('A') + i)
                                print(f"   {letter}) {option}")
                                break
            
            print(f"‚è±Ô∏è  Czas odpowiedzi: {response_time:.2f}s")
            
            questions_count += 1
            time.sleep(2)
        
        # Poka≈º statystyki sesji
        self.show_session_results()
    
    def show_session_results(self):
        """Wy≈õwietla wyniki sesji"""
        stats = self.quiz_manager.get_session_stats()
        
        self.clear_screen()
        self.print_header("Wyniki Sesji")
        
        print(f"\nüìä Statystyki:")
        print(f"   Zadane pytania: {stats['questions_asked']}")
        print(f"   Poprawne odpowiedzi: {stats['correct_answers']}")
        print(f"   Dok≈Çadno≈õƒá: {stats['accuracy']:.1f}%")
        print(f"   Czas sesji: {stats['elapsed_time']:.0f}s")
        
        # Oce≈Ñ wyniki
        if stats['accuracy'] >= 90:
            print("\nüèÜ Fantastyczne wyniki! Jeste≈õ mistrzem!")
        elif stats['accuracy'] >= 75:
            print("\nüëç Bardzo dobre wyniki! Tak trzymaj!")
        elif stats['accuracy'] >= 60:
            print("\nüìö Nie≈∫le! Jeszcze trochƒô nauki i bƒôdzie perfekcyjnie!")
        else:
            print("\nüí™ Nie poddawaj siƒô! Praktyka czyni mistrza!")
        
        input("\nNaci≈õnij Enter, aby wr√≥ciƒá do menu...")
    
    def show_statistics(self):
        """Wy≈õwietla statystyki"""
        self.clear_screen()
        self.print_header("Statystyki")
        
        # Statystyki aktualnego quizu
        if self.quiz_manager.current_quiz_file:
            quiz_stats = self.quiz_manager.get_quiz_statistics()
            print(f"\nüìñ Quiz: {self.quiz_manager.get_quiz_name()}")
            print(f"   Pytania w bazie: {quiz_stats['total_questions']}")
            print(f"   Udzielone odpowiedzi: {quiz_stats['total_answers']}")
            print(f"   Poprawne odpowiedzi: {quiz_stats['correct_answers']}")
            print(f"   Dok≈Çadno≈õƒá: {quiz_stats['accuracy']:.1f}%")
            print(f"   Opanowane pytania: {quiz_stats['learned_questions']}")
            print(f"   ≈örednia trudno≈õƒá: {quiz_stats['avg_difficulty']:.2f}")
            if quiz_stats['avg_response_time']:
                print(f"   ≈öredni czas odpowiedzi: {quiz_stats['avg_response_time']:.2f}s")
        
        # Globalne statystyki
        global_stats = self.quiz_manager.get_global_statistics()
        print(f"\nüåç Statystyki globalne:")
        print(f"   Wszystkie pytania: {global_stats['total_questions']}")
        print(f"   Wszystkie odpowiedzi: {global_stats['total_answers']}")
        print(f"   Globalna dok≈Çadno≈õƒá: {global_stats['accuracy']:.1f}%")
        print(f"   Opanowane pytania: {global_stats['learned_questions']}")
        
        input("\nNaci≈õnij Enter, aby wr√≥ciƒá do menu...")
    
    def show_problem_questions(self):
        """Wy≈õwietla problematyczne pytania"""
        if not self.quiz_manager.current_quiz_file:
            self.clear_screen()
            print("‚ùå Najpierw wybierz quiz!")
            input("Naci≈õnij Enter, aby kontynuowaƒá...")
            return
        
        problems = self.quiz_manager.get_problem_questions()
        
        self.clear_screen()
        self.print_header("Problematyczne Pytania")
        
        if not problems:
            print("\nüéâ ≈öwietnie! Brak problematycznych pyta≈Ñ!")
            print("üí° Wszystkie pytania sƒÖ dobrze opanowane.")
        else:
            print(f"\nüîç Znaleziono {len(problems)} problematycznych pyta≈Ñ:")
            print("\n" + "="*60)
            
            for i, (q_id, question, answer, total, correct, accuracy) in enumerate(problems, 1):
                print(f"\n{i}. {question}")
                print(f"   üí° Odpowied≈∫: {answer}")
                print(f"   üìä Dok≈Çadno≈õƒá: {accuracy*100:.1f}% ({correct}/{total})")
                print("-" * 40)
        
        input("\nNaci≈õnij Enter, aby wr√≥ciƒá do menu...")
    
    def show_settings_menu(self):
        """Wy≈õwietla menu ustawie≈Ñ"""
        options = [
            "üìÅ Utw√≥rz przyk≈Çadowe quizy",
            "üóÇÔ∏è  Poka≈º lokalizacjƒô plik√≥w",
            "üîß Informacje o aplikacji"
        ]
        
        self.clear_screen()
        self.print_menu(options, "Ustawienia i Narzƒôdzia")
        
        choice = self.get_user_choice(len(options))
        
        if choice == 0:
            return
        elif choice == 1:
            self.quiz_manager.create_sample_quizzes()
            print("\n‚úÖ Utworzono przyk≈Çadowe quizy w katalogu 'quizy'!")
            input("Naci≈õnij Enter, aby kontynuowaƒá...")
        elif choice == 2:
            self.show_file_locations()
        elif choice == 3:
            self.show_about()
    
    def show_file_locations(self):
        """Wy≈õwietla informacje o lokalizacji plik√≥w"""
        self.clear_screen()
        self.print_header("Lokalizacja Plik√≥w")
        
        current_dir = os.getcwd()
        print(f"\nüìÅ Katalog roboczy: {current_dir}")
        print(f"üìö Quizy: {current_dir}/quizy/")
        print(f"üóÑÔ∏è  Baza danych: {current_dir}/data/zakuzaku.db")
        
        print("\nüìù Obs≈Çugiwane formaty:")
        print("   ‚Ä¢ JSON (.json) - strukturalne quizy")
        print("   ‚Ä¢ Markdown (.md) - proste quizy tekstowe")
        
        print("\nüí° Przyk≈Çad pliku JSON:")
        print('''   {
     "hello": "cze≈õƒá",
     "goodbye": "≈ºegnaj"
   }''')
        
        print("\nüí° Przyk≈Çad pliku Markdown:")
        print('''   Q: Jak siƒô masz?
   A: Dobrze, dziƒôkujƒô
   
   Q: Co robisz?
   A: Uczƒô siƒô''')
        
        input("\nNaci≈õnij Enter, aby wr√≥ciƒá...")
    
    def show_about(self):
        """Wy≈õwietla informacje o aplikacji"""
        self.clear_screen()
        self.print_header("O Aplikacji")
        
        print("\nüéì ZakuZaku - Aplikacja Edukacyjna")
        print("üìÖ Wersja 1.0")
        print("\nüìã Funkcje:")
        print("   ‚Ä¢ System inteligentnych powt√≥rek (SRS)")
        print("   ‚Ä¢ Obs≈Çuga plik√≥w JSON i Markdown")
        print("   ‚Ä¢ ≈öledzenie postƒôp√≥w nauki")
        print("   ‚Ä¢ Analiza problematycznych pyta≈Ñ")
        print("   ‚Ä¢ Statystyki i raporty")
        
        print("\nüõ†Ô∏è  Technologie:")
        print("   ‚Ä¢ Python 3.x")
        print("   ‚Ä¢ SQLite (baza danych)")
        print("   ‚Ä¢ Interface terminalowy")
        
        print("\nüí° Algorytm SRS:")
        print("   Pytania sƒÖ prezentowane w optymalnych interwa≈Çach")
        print("   na podstawie Twojej skuteczno≈õci w odpowiedziach.")
        
        input("\nNaci≈õnij Enter, aby wr√≥ciƒá...")
